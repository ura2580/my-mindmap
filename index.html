<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#007acc">
  <meta name="description" content="ê°œì¸ìš© ë§ˆì¸ë“œë§µ PWA - ëª¨ë“  ê¸°ê¸°ì—ì„œ ë„¤ì´í‹°ë¸Œ ì•±ì²˜ëŸ¼ ì‚¬ìš©">
  <title>ë‚´ ë§ˆì¸ë“œë§µ PWA v53</title>
  
  <!-- PWA ë§¤ë‹ˆí˜ìŠ¤íŠ¸ -->
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="icon-192.png">
  <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="icon-512.png">
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- React 18 -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  
  <!-- Babel Standalone -->
  <script src="https://unpkg.com/@babel/standalone@7/babel.min.js"></script>
  
  <!-- Lucide Icons -->
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
  
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
      background: #f3f4f6;
    }
    #root {
      width: 100vw;
      height: 100vh;
    }
    
    /* PWA ìŠ¤íƒ€ì¼ */
    .pwa-install-prompt {
      animation: slideDown 0.3s ease-out;
    }
    
    @keyframes slideDown {
      from { transform: translateY(-100%); }
      to { transform: translateY(0); }
    }
    
    /* ë¡œë”© ì• ë‹ˆë©”ì´ì…˜ */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      font-size: 18px;
      color: #666;
    }
    
    .spinner {
      border: 3px solid #f3f4f6;
      border-top: 3px solid #007acc;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin-right: 10px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <!-- ë¡œë”© í™”ë©´ -->
  <div id="loading" class="loading">
    <div class="spinner"></div>
    ë§ˆì¸ë“œë§µ PWA ë¡œë”© ì¤‘...
  </div>
  
  <!-- React ì•±ì´ ë Œë”ë§ë  ê³³ -->
  <div id="root"></div>

  <script type="text/babel">
    // ë¡œë”© ìƒíƒœ ê´€ë¦¬
    const hideLoading = () => {
      const loadingEl = document.getElementById('loading');
      if (loadingEl) {
        loadingEl.style.display = 'none';
      }
    };

    // React ë° ì•„ì´ì½˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ í™•ì¸
    if (!window.React || !window.ReactDOM || !window.lucide) {
      document.getElementById('loading').innerHTML = 
        '<div style="color: red;">í•„ìˆ˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œë”© ì‹¤íŒ¨. ì¸í„°ë„· ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”.</div>';
    } else {
      // ì„±ê³µì ìœ¼ë¡œ ë¡œë“œë˜ë©´ ì•± ì‹œì‘
      startApp();
    }

    function startApp() {
      const { useState, useRef, useCallback, useEffect } = React;
      const { createRoot } = ReactDOM;

      // Lucide ì•„ì´ì½˜ë“¤
      const {
        Square, Circle, Diamond, MousePointer, Trash2, Copy, 
        RotateCcw, RotateCw, ZoomIn, ZoomOut, Move, Download, Upload
      } = lucide;

      const MiroMindMap = () => {
        const canvasRef = useRef(null);
        const [nodes, setNodes] = useState([]);
        const [connections, setConnections] = useState([]);
        const [selectedTool, setSelectedTool] = useState('select');
        const [selectedNodes, setSelectedNodes] = useState([]);
        const [isDragging, setIsDragging] = useState(false);
        const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
        const [canvasOffset, setCanvasOffset] = useState({ x: 0, y: 0 });
        const [zoom, setZoom] = useState(1);
        const [connectingFrom, setConnectingFrom] = useState(null);
        const [editingNode, setEditingNode] = useState(null);
        const [clipboard, setClipboard] = useState([]);
        const [history, setHistory] = useState([]);
        const [historyIndex, setHistoryIndex] = useState(-1);
        const [selectionBox, setSelectionBox] = useState(null);
        const [isSelecting, setIsSelecting] = useState(false);
        const [smartGuides, setSmartGuides] = useState([]);
        const [contextMenu, setContextMenu] = useState(null);
        const [isMiddleMouseDown, setIsMiddleMouseDown] = useState(false);
        const [isInstallPromptVisible, setIsInstallPromptVisible] = useState(false);
        const [deferredPrompt, setDeferredPrompt] = useState(null);

        // ì•± ë¡œë”© ì™„ë£Œ ì•Œë¦¼
        useEffect(() => {
          hideLoading();
        }, []);

        // PWA ì„¤ì¹˜ ì²˜ë¦¬
        useEffect(() => {
          const handleBeforeInstallPrompt = (e) => {
            e.preventDefault();
            setDeferredPrompt(e);
            setIsInstallPromptVisible(true);
          };

          const handleAppInstalled = () => {
            setIsInstallPromptVisible(false);
            setDeferredPrompt(null);
            console.log('PWAê°€ ì„±ê³µì ìœ¼ë¡œ ì„¤ì¹˜ë˜ì—ˆìŠµë‹ˆë‹¤!');
          };

          window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
          window.addEventListener('appinstalled', handleAppInstalled);

          return () => {
            window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
            window.removeEventListener('appinstalled', handleAppInstalled);
          };
        }, []);

        const handleInstallClick = async () => {
          if (deferredPrompt) {
            deferredPrompt.prompt();
            const { outcome } = await deferredPrompt.userChoice;
            setDeferredPrompt(null);
            setIsInstallPromptVisible(false);
          }
        };

        // ë…¸ë“œ íƒ€ì… ì •ì˜
        const nodeTypes = {
          rectangle: { width: 120, height: 80, shape: 'rectangle' },
          circle: { width: 100, height: 100, shape: 'circle' },
          diamond: { width: 120, height: 80, shape: 'diamond' },
          sticky: { width: 140, height: 100, shape: 'sticky' }
        };

        // íˆìŠ¤í† ë¦¬ ì €ì¥
        const saveToHistory = useCallback(() => {
          const state = { nodes, connections };
          const newHistory = history.slice(0, historyIndex + 1);
          newHistory.push(JSON.parse(JSON.stringify(state)));
          setHistory(newHistory);
          setHistoryIndex(newHistory.length - 1);
        }, [nodes, connections, history, historyIndex]);

        const undo = () => {
          if (historyIndex > 0) {
            const prevState = history[historyIndex - 1];
            setNodes(prevState.nodes);
            setConnections(prevState.connections);
            setHistoryIndex(historyIndex - 1);
          }
        };

        const redo = () => {
          if (historyIndex < history.length - 1) {
            const nextState = history[historyIndex + 1];
            setNodes(nextState.nodes);
            setConnections(nextState.connections);
            setHistoryIndex(historyIndex + 1);
          }
        };

        // ìŠ¤ë§ˆíŠ¸ ê°€ì´ë“œ ê³„ì‚°
        const calculateSmartGuides = useCallback((movingNodes) => {
          if (movingNodes.length === 0) return [];
          
          const guides = [];
          const snapThreshold = 8;
          const staticNodes = nodes.filter(node => !movingNodes.some(mn => mn.id === node.id));
          
          movingNodes.forEach(movingNode => {
            staticNodes.forEach(staticNode => {
              const movingCenterX = movingNode.x + movingNode.width / 2;
              const staticCenterX = staticNode.x + staticNode.width / 2;
              
              const centerDiff = Math.abs(movingCenterX - staticCenterX);
              if (centerDiff < snapThreshold) {
                const snapOffset = staticCenterX - movingCenterX;
                movingNode.x += snapOffset;
                
                guides.push({
                  type: 'vertical',
                  position: staticCenterX,
                  range: [
                    Math.min(movingNode.y, staticNode.y) - 20,
                    Math.max(movingNode.y + movingNode.height, staticNode.y + staticNode.height) + 20
                  ]
                });
              }
              
              const movingCenterY = movingNode.y + movingNode.height / 2;
              const staticCenterY = staticNode.y + staticNode.height / 2;
              
              const centerYDiff = Math.abs(movingCenterY - staticCenterY);
              if (centerYDiff < snapThreshold) {
                const snapOffset = staticCenterY - movingCenterY;
                movingNode.y += snapOffset;
                
                guides.push({
                  type: 'horizontal',
                  position: staticCenterY,
                  range: [
                    Math.min(movingNode.x, staticNode.x) - 20,
                    Math.max(movingNode.x + movingNode.width, staticNode.x + staticNode.width) + 20
                  ]
                });
              }
            });
          });
          
          return guides;
        }, [nodes]);

        // ì—°ê²°ì ì—ì„œ ìƒˆ ë…¸ë“œ ìƒì„±
        const createConnectedNode = (sourceNodeId, direction) => {
          const sourceNode = nodes.find(n => n.id === sourceNodeId);
          if (!sourceNode) return;

          let newX = sourceNode.x;
          let newY = sourceNode.y;
          const spacing = 150;

          switch (direction) {
            case 'top':
              newY = sourceNode.y - spacing;
              break;
            case 'right':
              newX = sourceNode.x + spacing;
              break;
            case 'bottom':
              newY = sourceNode.y + spacing;
              break;
            case 'left':
              newX = sourceNode.x - spacing;
              break;
          }

          const newNode = {
            id: Date.now() + Math.random(),
            x: newX,
            y: newY,
            width: sourceNode.width,
            height: sourceNode.height,
            text: 'New Node',
            color: sourceNode.color,
            borderColor: sourceNode.borderColor,
            textColor: sourceNode.textColor,
            shape: sourceNode.shape,
            fontSize: sourceNode.fontSize,
            zIndex: nodes.length
          };

          const newConnection = {
            id: Date.now() + Math.random() + 1,
            from: sourceNodeId,
            to: newNode.id,
            color: '#666666',
            width: 2,
            style: 'solid',
            hasArrow: true
          };

          setNodes(prev => [...prev, newNode]);
          setConnections(prev => [...prev, newConnection]);
          setSelectedNodes([newNode.id]);
          saveToHistory();
        };

        // ë…¸ë“œ ìƒì„±
        const createNode = (x, y, type = 'rectangle') => {
          const nodeConfig = nodeTypes[type];
          const newNode = {
            id: Date.now() + Math.random(),
            x: (x - canvasOffset.x) / zoom,
            y: (y - canvasOffset.y) / zoom,
            width: nodeConfig.width,
            height: nodeConfig.height,
            text: 'New Node',
            color: '#ffffff',
            borderColor: '#333333',
            textColor: '#000000',
            shape: nodeConfig.shape,
            fontSize: 14,
            zIndex: nodes.length
          };
          
          setNodes(prev => [...prev, newNode]);
          saveToHistory();
        };

        // ìº”ë²„ìŠ¤ í´ë¦­ ì²˜ë¦¬
        const handleCanvasClick = (e) => {
          setSelectedNodes([]);
          setConnectingFrom(null);
          setContextMenu(null);
          
          if (selectedTool === 'select') return;
          
          const rect = canvasRef.current.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          
          if (selectedTool !== 'select' && selectedTool !== 'connect') {
            createNode(x, y, selectedTool);
            setSelectedTool('select');
          }
        };

        // ë…¸ë“œ ì„ íƒ
        const selectNode = (nodeId, e) => {
          e.stopPropagation();
          
          if (selectedTool === 'connect') {
            if (!connectingFrom) {
              setConnectingFrom(nodeId);
            } else {
              if (connectingFrom !== nodeId) {
                const newConnection = {
                  id: Date.now() + Math.random(),
                  from: connectingFrom,
                  to: nodeId,
                  color: '#666666',
                  width: 2,
                  style: 'solid',
                  hasArrow: true
                };
                setConnections(prev => [...prev, newConnection]);
                saveToHistory();
              }
              setConnectingFrom(null);
            }
            return;
          }

          if (e.ctrlKey || e.metaKey) {
            setSelectedNodes(prev => 
              prev.includes(nodeId) 
                ? prev.filter(id => id !== nodeId)
                : [...prev, nodeId]
            );
          } else {
            setSelectedNodes([nodeId]);
            
            const node = nodes.find(n => n.id === nodeId);
            if (node) {
              setContextMenu({
                nodeId,
                x: (node.x + node.width / 2) * zoom + canvasOffset.x,
                y: (node.y - 60) * zoom + canvasOffset.y
              });
            }
          }
        };

        // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ë“¤
        const handleCanvasMouseDown = (e) => {
          if (e.button === 1) {
            e.preventDefault();
            setIsMiddleMouseDown(true);
            setDragStart({ x: e.clientX, y: e.clientY });
            return;
          }

          if (selectedTool !== 'select') return;
          
          const rect = canvasRef.current.getBoundingClientRect();
          const startX = e.clientX - rect.left;
          const startY = e.clientY - rect.top;
          
          setIsSelecting(true);
          setSelectionBox({
            startX: (startX - canvasOffset.x) / zoom,
            startY: (startY - canvasOffset.y) / zoom,
            endX: (startX - canvasOffset.x) / zoom,
            endY: (startY - canvasOffset.y) / zoom
          });
        };

        const handleMouseDown = (nodeId, e) => {
          if (e.button === 1) {
            e.preventDefault();
            setIsMiddleMouseDown(true);
            setDragStart({ x: e.clientX, y: e.clientY });
            return;
          }

          if (selectedTool === 'connect') return;
          
          e.stopPropagation();
          setIsDragging(true);
          setDragStart({ x: e.clientX, y: e.clientY });
          
          if (!selectedNodes.includes(nodeId)) {
            setSelectedNodes([nodeId]);
          }
        };

        const handleMouseMove = (e) => {
          if (isMiddleMouseDown) {
            const deltaX = e.clientX - dragStart.x;
            const deltaY = e.clientY - dragStart.y;
            
            setCanvasOffset(prev => ({
              x: prev.x + deltaX,
              y: prev.y + deltaY
            }));
            
            setDragStart({ x: e.clientX, y: e.clientY });
            return;
          }

          if (isSelecting) {
            const rect = canvasRef.current.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;
            
            setSelectionBox(prev => ({
              ...prev,
              endX: (currentX - canvasOffset.x) / zoom,
              endY: (currentY - canvasOffset.y) / zoom
            }));
            return;
          }
          
          if (!isDragging || selectedNodes.length === 0) return;

          const deltaX = (e.clientX - dragStart.x) / zoom;
          const deltaY = (e.clientY - dragStart.y) / zoom;

          const movingNodes = nodes.filter(node => selectedNodes.includes(node.id))
            .map(node => ({ ...node, x: node.x + deltaX, y: node.y + deltaY }));
          
          const guides = calculateSmartGuides(movingNodes);
          setSmartGuides(guides);

          setNodes(prev => prev.map(node => 
            selectedNodes.includes(node.id) 
              ? { ...node, x: node.x + deltaX, y: node.y + deltaY }
              : node
          ));

          setDragStart({ x: e.clientX, y: e.clientY });
        };

        const handleMouseUp = (e) => {
          if (isMiddleMouseDown) {
            setIsMiddleMouseDown(false);
            return;
          }

          if (isSelecting) {
            if (selectionBox) {
              const { startX, startY, endX, endY } = selectionBox;
              const minX = Math.min(startX, endX);
              const maxX = Math.max(startX, endX);
              const minY = Math.min(startY, endY);
              const maxY = Math.max(startY, endY);
              
              const selectedNodeIds = nodes
                .filter(node => {
                  const nodeRight = node.x + node.width;
                  const nodeBottom = node.y + node.height;
                  
                  return node.x < maxX && nodeRight > minX && 
                         node.y < maxY && nodeBottom > minY;
                })
                .map(node => node.id);
              
              setSelectedNodes(selectedNodeIds);
            }
            setSelectionBox(null);
            setIsSelecting(false);
          }
          
          if (isDragging) {
            setSmartGuides([]);
            saveToHistory();
          }
          setIsDragging(false);
        };

        // ì¤Œ/íŒ¬ ì²˜ë¦¬
        const handleWheel = (e) => {
          e.preventDefault();
          
          if (e.ctrlKey || e.metaKey) {
            const rect = canvasRef.current.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const zoomFactor = e.deltaY < 0 ? 1.05 : 0.95;
            const newZoom = Math.max(0.1, Math.min(5, zoom * zoomFactor));
            
            const scaleFactor = newZoom / zoom;
            
            setCanvasOffset(prev => ({
              x: mouseX - (mouseX - prev.x) * scaleFactor,
              y: mouseY - (mouseY - prev.y) * scaleFactor
            }));
            
            setZoom(newZoom);
          } else {
            const panSpeed = 1.2;
            setCanvasOffset(prev => ({
              x: prev.x - e.deltaX * panSpeed,
              y: prev.y - e.deltaY * panSpeed
            }));
          }
        };

        // í…ìŠ¤íŠ¸ í¸ì§‘
        const handleDoubleClick = (nodeId, e) => {
          e.stopPropagation();
          setEditingNode(nodeId);
        };

        const updateNodeText = (nodeId, text) => {
          setNodes(prev => prev.map(node =>
            node.id === nodeId ? { ...node, text } : node
          ));
          setEditingNode(null);
          saveToHistory();
        };

        const updateNodeStyle = (nodeId, updates) => {
          setNodes(prev => prev.map(node =>
            node.id === nodeId ? { ...node, ...updates } : node
          ));
          saveToHistory();
        };

        // ì‚­ì œ/ë³µì‚¬
        const deleteSelected = () => {
          setNodes(prev => prev.filter(node => !selectedNodes.includes(node.id)));
          setConnections(prev => prev.filter(conn => 
            !selectedNodes.includes(conn.from) && !selectedNodes.includes(conn.to)
          ));
          setSelectedNodes([]);
          saveToHistory();
        };

        const copySelected = () => {
          const selectedNodesData = nodes.filter(node => selectedNodes.includes(node.id));
          setClipboard(selectedNodesData);
        };

        const paste = () => {
          if (clipboard.length === 0) return;
          
          const newNodes = clipboard.map(node => ({
            ...node,
            id: Date.now() + Math.random(),
            x: node.x + 20,
            y: node.y + 20
          }));
          
          setNodes(prev => [...prev, ...newNodes]);
          setSelectedNodes(newNodes.map(node => node.id));
          saveToHistory();
        };

        // íŒŒì¼ ì €ì¥/ë¡œë“œ
        const saveProject = () => {
          const project = {
            nodes,
            connections,
            canvasOffset,
            zoom,
            timestamp: new Date().toISOString(),
            version: '1.0',
            appVersion: 'PWA-v53'
          };
          
          try {
            const jsonString = JSON.stringify(project, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `mindmap-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
            link.style.display = 'none';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            setTimeout(() => {
              URL.revokeObjectURL(url);
            }, 100);
            
            alert('ë§ˆì¸ë“œë§µì´ ì„±ê³µì ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤! ğŸ’¾');
          } catch (error) {
            alert('ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
          }
        };

        const loadProject = (e) => {
          const file = e.target.files[0];
          if (!file) return;
          
          if (!file.name.toLowerCase().endsWith('.json')) {
            alert('JSON íŒŒì¼ë§Œ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
            return;
          }
          
          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              const project = JSON.parse(event.target.result);
              
              if (!project.nodes || !Array.isArray(project.nodes)) {
                throw new Error('ìœ íš¨í•˜ì§€ ì•Šì€ íŒŒì¼ì…ë‹ˆë‹¤.');
              }
              
              setNodes(project.nodes || []);
              setConnections(project.connections || []);
              setCanvasOffset(project.canvasOffset || { x: 0, y: 0 });
              setZoom(project.zoom || 1);
              setSelectedNodes([]);
              setContextMenu(null);
              saveToHistory();
              
              alert('ë§ˆì¸ë“œë§µì´ ì„±ê³µì ìœ¼ë¡œ ë¶ˆëŸ¬ì™€ì¡ŒìŠµë‹ˆë‹¤! ğŸ“‚');
            } catch (error) {
              alert('íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            }
          };
          
          reader.readAsText(file);
          e.target.value = '';
        };

        // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤
        useEffect(() => {
          const handleKeyDown = (e) => {
            if (editingNode) return;
            
            if (e.ctrlKey || e.metaKey) {
              switch (e.key) {
                case 'z':
                  e.preventDefault();
                  e.shiftKey ? redo() : undo();
                  break;
                case 'y':
                  e.preventDefault();
                  redo();
                  break;
                case 'c':
                  e.preventDefault();
                  copySelected();
                  break;
                case 'v':
                  e.preventDefault();
                  paste();
                  break;
                case 's':
                  e.preventDefault();
                  saveProject();
                  break;
                case 'a':
                  e.preventDefault();
                  setSelectedNodes(nodes.map(n => n.id));
                  break;
              }
            } else if (e.key === 'Delete' || e.key === 'Backspace') {
              deleteSelected();
            } else if (e.key === 'Escape') {
              setSelectedNodes([]);
              setConnectingFrom(null);
              setSelectedTool('select');
              setContextMenu(null);
            }
          };

          window.addEventListener('keydown', handleKeyDown);
          return () => window.removeEventListener('keydown', handleKeyDown);
        }, [selectedNodes, clipboard, historyIndex, nodes, editingNode]);

        // ì—°ê²°ì„  ë Œë”ë§
        const renderConnection = (connection) => {
          const fromNode = nodes.find(n => n.id === connection.from);
          const toNode = nodes.find(n => n.id === connection.to);
          
          if (!fromNode || !toNode) return null;
          
          const fromCenterX = fromNode.x + fromNode.width / 2;
          const fromCenterY = fromNode.y + fromNode.height / 2;
          const toCenterX = toNode.x + toNode.width / 2;
          const toCenterY = toNode.y + toNode.height / 2;
          
          const deltaX = toCenterX - fromCenterX;
          const deltaY = toCenterY - fromCenterY;
          
          let fromX, fromY, toX, toY;
          
          if (Math.abs(deltaX) > Math.abs(deltaY)) {
            if (deltaX > 0) {
              fromX = fromNode.x + fromNode.width;
              fromY = fromCenterY;
              toX = toNode.x;
              toY = toCenterY;
            } else {
              fromX = fromNode.x;
              fromY = fromCenterY;
              toX = toNode.x + toNode.width;
              toY = toCenterY;
            }
          } else {
            if (deltaY > 0) {
              fromX = fromCenterX;
              fromY = fromNode.y + fromNode.height;
              toX = toCenterX;
              toY = toNode.y;
            } else {
              fromX = fromCenterX;
              fromY = fromNode.y;
              toX = toCenterX;
              toY = toNode.y + toNode.height;
            }
          }
          
          const screenFromX = fromX * zoom + canvasOffset.x;
          const screenFromY = fromY * zoom + canvasOffset.y;
          const screenToX = toX * zoom + canvasOffset.x;
          const screenToY = toY * zoom + canvasOffset.y;
          
          const angle = Math.atan2(screenToY - screenFromY, screenToX - screenFromX);
          const arrowLength = Math.max(8, 12 * zoom);
          const arrowAngle = Math.PI / 5;
          
          const arrowX1 = screenToX - arrowLength * Math.cos(angle - arrowAngle);
          const arrowY1 = screenToY - arrowLength * Math.sin(angle - arrowAngle);
          const arrowX2 = screenToX - arrowLength * Math.cos(angle + arrowAngle);
          const arrowY2 = screenToY - arrowLength * Math.sin(angle + arrowAngle);
          
          return (
            <g key={connection.id}>
              <line
                x1={screenFromX}
                y1={screenFromY}
                x2={screenToX}
                y2={screenToY}
                stroke={connection.color}
                strokeWidth={Math.max(1, connection.width * zoom)}
              />
              {connection.hasArrow && (
                <polygon
                  points={`${screenToX},${screenToY} ${arrowX1},${arrowY1} ${arrowX2},${arrowY2}`}
                  fill={connection.color}
                />
              )}
            </g>
          );
        };

        // ë…¸ë“œ ë Œë”ë§
        const renderNode = (node) => {
          const x = node.x * zoom + canvasOffset.x;
          const y = node.y * zoom + canvasOffset.y;
          const width = node.width * zoom;
          const height = node.height * zoom;
          const isSelected = selectedNodes.includes(node.id);
          
          let nodeElement;
          
          switch (node.shape) {
            case 'circle':
              nodeElement = (
                <ellipse
                  cx={x + width / 2}
                  cy={y + height / 2}
                  rx={width / 2}
                  ry={height / 2}
                  fill={node.color}
                  stroke={isSelected ? '#007acc' : node.borderColor}
                  strokeWidth={isSelected ? 3 : 2}
                />
              );
              break;
            case 'diamond':
              const centerX = x + width / 2;
              const centerY = y + height / 2;
              nodeElement = (
                <polygon
                  points={`${centerX},${y} ${x + width},${centerY} ${centerX},${y + height} ${x},${centerY}`}
                  fill={node.color}
                  stroke={isSelected ? '#007acc' : node.borderColor}
                  strokeWidth={isSelected ? 3 : 2}
                />
              );
              break;
            case 'sticky':
              nodeElement = (
                <g>
                  <rect
                    x={x}
                    y={y}
                    width={width}
                    height={height}
                    fill="#fff3cd"
                    stroke="#ffc107"
                    strokeWidth={2}
                    rx={5}
                  />
                  <polygon
                    points={`${x + width - 15},${y} ${x + width},${y} ${x + width},${y + 15}`}
                    fill="#ffc107"
                  />
                </g>
              );
              break;
            default:
              nodeElement = (
                <rect
                  x={x}
                  y={y}
                  width={width}
                  height={height}
                  fill={node.color}
                  stroke={isSelected ? '#007acc' : node.borderColor}
                  strokeWidth={isSelected ? 3 : 2}
                  rx={5}
                />
              );
          }

          return (
            <g key={node.id}>
              {nodeElement}
              {editingNode === node.id ? (
                <foreignObject x={x} y={y + height/2 - 10} width={width} height={20}>
                  <input
                    type="text"
                    defaultValue={node.text}
                    style={{
                      width: '100%',
                      border: 'none',
                      background: 'transparent',
                      textAlign: 'center',
                      fontSize: `${node.fontSize * zoom}px`,
                      color: node.textColor
                    }}
                    autoFocus
                    onBlur={(e) => updateNodeText(node.id, e.target.value)}
                    onKeyDown={(e) => {
                      if (e.key === 'Enter') {
                        updateNodeText(node.id, e.target.value);
                      }
                    }}
                  />
                </foreignObject>
              ) : (
                <text
                  x={x + width / 2}
                  y={y + height / 2}
                  textAnchor="middle"
                  dominantBaseline="middle"
                  fill={node.textColor}
                  fontSize={node.fontSize * zoom}
                  style={{ userSelect: 'none', pointerEvents: 'none' }}
                >
                  {node.text}
                </text>
              )}
              <rect
                x={x}
                y={y}
                width={width}
                height={height}
                fill="transparent"
                style={{ cursor: 'move' }}
                onMouseDown={(e) => handleMouseDown(node.id, e)}
                onClick={(e) => selectNode(node.id, e)}
                onDoubleClick={(e) => handleDoubleClick(node.id, e)}
              />
              
              {isSelected && selectedTool === 'select' && selectedNodes.length === 1 && (
                <g>
                  <circle
                    cx={x + width / 2}
                    cy={y}
                    r={6}
                    fill="#007acc"
                    stroke="white"
                    strokeWidth={2}
                    style={{ cursor: 'pointer' }}
                    onClick={(e) => {
                      e.stopPropagation();
                      createConnectedNode(node.id, 'top');
                    }}
                  />
                  <circle
                    cx={x + width}
                    cy={y + height / 2}
                    r={6}
                    fill="#007acc"
                    stroke="white"
                    strokeWidth={2}
                    style={{ cursor: 'pointer' }}
                    onClick={(e) => {
                      e.stopPropagation();
                      createConnectedNode(node.id, 'right');
                    }}
                  />
                  <circle
                    cx={x + width / 2}
                    cy={y + height}
                    r={6}
                    fill="#007acc"
                    stroke="white"
                    strokeWidth={2}
                    style={{ cursor: 'pointer' }}
                    onClick={(e) => {
                      e.stopPropagation();
                      createConnectedNode(node.id, 'bottom');
                    }}
                  />
                  <circle
                    cx={x}
                    cy={y + height / 2}
                    r={6}
                    fill="#007acc"
                    stroke="white"
                    strokeWidth={2}
                    style={{ cursor: 'pointer' }}
                    onClick={(e) => {
                      e.stopPropagation();
                      createConnectedNode(node.id, 'left');
                    }}
                  />
                </g>
              )}
            </g>
          );
        };

        // ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´
        const renderContextMenu = () => {
          if (!contextMenu) return null;
          
          const selectedNode = nodes.find(n => n.id === contextMenu.nodeId);
          if (!selectedNode) return null;

          return (
            <div
              className="absolute bg-white rounded-lg shadow-xl border border-gray-200 p-2 flex items-center gap-1 z-50"
              style={{
                left: Math.max(10, Math.min(contextMenu.x - 150, window.innerWidth - 320)),
                top: Math.max(10, contextMenu.y)
              }}
              onClick={(e) => e.stopPropagation()}
            >
              <select
                value={selectedNode.shape}
                onChange={(e) => updateNodeStyle(selectedNode.id, { shape: e.target.value })}
                className="p-1 border rounded text-xs"
              >
                <option value="rectangle">ğŸ”³</option>
                <option value="circle">â­•</option>
                <option value="diamond">â™¦ï¸</option>
                <option value="sticky">ğŸ“„</option>
              </select>

              <input
                type="number"
                value={selectedNode.fontSize}
                onChange={(e) => updateNodeStyle(selectedNode.id, { fontSize: parseInt(e.target.value) })}
                className="w-12 p-1 border rounded text-xs"
                min="8"
                max="72"
              />

              <input
                type="color"
                value={selectedNode.textColor}
                onChange={(e) => updateNodeStyle(selectedNode.id, { textColor: e.target.value })}
                className="w-6 h-6 border-0 rounded cursor-pointer"
              />

              <input
                type="color"
                value={selectedNode.borderColor}
                onChange={(e) => updateNodeStyle(selectedNode.id, { borderColor: e.target.value })}
                className="w-6 h-6 border-0 rounded cursor-pointer"
              />

              <input
                type="color"
                value={selectedNode.color}
                onChange={(e) => updateNodeStyle(selectedNode.id, { color: e.target.value })}
                className="w-6 h-6 border-0 rounded cursor-pointer"
              />

              <button
                onClick={() => setContextMenu(null)}
                className="ml-2 p-1 hover:bg-gray-100 rounded text-gray-500"
              >
                Ã—
              </button>
            </div>
          );
        };

        return (
          <div className="w-full h-screen bg-gray-100 flex flex-col relative">
            {/* PWA ì„¤ì¹˜ í”„ë¡¬í”„íŠ¸ */}
            {isInstallPromptVisible && (
              <div className="bg-gradient-to-r from-blue-600 to-purple-600 text-white p-3 flex items-center justify-between shadow-lg pwa-install-prompt">
                <div className="flex items-center gap-3">
                  <div className="text-2xl">ğŸ“±</div>
                  <div>
                    <div className="font-semibold">ì•±ìœ¼ë¡œ ì„¤ì¹˜í•˜ì„¸ìš”!</div>
                    <div className="text-sm opacity-90">ì˜¤í”„ë¼ì¸ì—ì„œë„ ì‚¬ìš©í•˜ê³  ë” ë¹ ë¥´ê²Œ ì ‘ê·¼í•˜ì„¸ìš”</div>
                  </div>
                </div>
                <div className="flex gap-2">
                  <button
                    onClick={handleInstallClick}
                    className="bg-white text-blue-600 px-4 py-2 rounded-lg font-semibold hover:bg-blue-50"
                  >
                    ì„¤ì¹˜
                  </button>
                  <button
                    onClick={() => setIsInstallPromptVisible(false)}
                    className="text-white hover:bg-white hover:bg-opacity-20 px-3 py-2 rounded-lg"
                  >
                    âœ•
                  </button>
                </div>
              </div>
            )}

            {/* PWA ì•ˆë‚´ */}
            <div className="bg-green-50 border-b border-green-200 p-2 text-sm text-green-700 text-center">
              ğŸŒŸ <strong>PWA ì§€ì›:</strong> Chrome/Edge/Safariì—ì„œ "ì„¤ì¹˜" ë˜ëŠ” "í™ˆ í™”ë©´ì— ì¶”ê°€"ë¡œ ë„¤ì´í‹°ë¸Œ ì•±ì²˜ëŸ¼ ì‚¬ìš©í•˜ì„¸ìš”!
            </div>

            {renderContextMenu()}

            {/* íˆ´ë°” */}
            <div className="bg-white border-b border-gray-300 p-2 flex items-center gap-2 flex-wrap">
              <div className="flex items-center gap-1 border-r pr-2">
                <button
                  className={`p-2 rounded ${selectedTool === 'select' ? 'bg-blue-100 text-blue-600' : 'hover:bg-gray-100'}`}
                  onClick={() => setSelectedTool('select')}
                >
                  <MousePointer size={18} />
                </button>
                <button
                  className={`p-2 rounded ${selectedTool === 'rectangle' ? 'bg-blue-100 text-blue-600' : 'hover:bg-gray-100'}`}
                  onClick={() => setSelectedTool('rectangle')}
                >
                  <Square size={18} />
                </button>
                <button
                  className={`p-2 rounded ${selectedTool === 'circle' ? 'bg-blue-100 text-blue-600' : 'hover:bg-gray-100'}`}
                  onClick={() => setSelectedTool('circle')}
                >
                  <Circle size={18} />
                </button>
                <button
                  className={`p-2 rounded ${selectedTool === 'diamond' ? 'bg-blue-100 text-blue-600' : 'hover:bg-gray-100'}`}
                  onClick={() => setSelectedTool('diamond')}
                >
                  <Diamond size={18} />
                </button>
                <button
                  className={`p-2 rounded ${selectedTool === 'sticky' ? 'bg-blue-100 text-blue-600' : 'hover:bg-gray-100'}`}
                  onClick={() => setSelectedTool('sticky')}
                >
                  ğŸ“„
                </button>
                <button
                  className={`p-2 rounded ${selectedTool === 'connect' ? 'bg-blue-100 text-blue-600' : 'hover:bg-gray-100'}`}
                  onClick={() => setSelectedTool('connect')}
                >
                  â†”ï¸
                </button>
              </div>

              <div className="flex items-center gap-1 border-r pr-2">
                <button
                  className="p-2 rounded hover:bg-gray-100"
                  onClick={undo}
                  disabled={historyIndex <= 0}
                >
                  <RotateCcw size={18} />
                </button>
                <button
                  className="p-2 rounded hover:bg-gray-100"
                  onClick={redo}
                  disabled={historyIndex >= history.length - 1}
                >
                  <RotateCw size={18} />
                </button>
                <button
                  className="p-2 rounded hover:bg-gray-100"
                  onClick={copySelected}
                  disabled={selectedNodes.length === 0}
                >
                  <Copy size={18} />
                </button>
                <button
                  className="p-2 rounded hover:bg-gray-100"
                  onClick={deleteSelected}
                  disabled={selectedNodes.length === 0}
                >
                  <Trash2 size={18} />
                </button>
              </div>

              <div className="flex items-center gap-1 border-r pr-2">
                <button
                  className="p-2 rounded hover:bg-gray-100"
                  onClick={() => setZoom(prev => Math.min(5, prev * 1.2))}
                >
                  <ZoomIn size={18} />
                </button>
                <button
                  className="p-2 rounded hover:bg-gray-100"
                  onClick={() => setZoom(prev => Math.max(0.1, prev / 1.2))}
                >
                  <ZoomOut size={18} />
                </button>
                <span className="text-sm text-gray-600 min-w-[60px] text-center">
                  {Math.round(zoom * 100)}%
                </span>
                <button
                  className="p-2 rounded hover:bg-gray-100"
                  onClick={() => {
                    setZoom(1);
                    setCanvasOffset({ x: 0, y: 0 });
                  }}
                >
                  <Move size={18} />
                </button>
              </div>

              <div className="flex items-center gap-1">
                <button
                  className="p-2 rounded hover:bg-gray-100"
                  onClick={saveProject}
                >
                  <Download size={18} />
                </button>
                <label className="p-2 rounded hover:bg-gray-100 cursor-pointer">
                  <Upload size={18} />
                  <input
                    type="file"
                    accept=".json,application/json"
                    onChange={loadProject}
                    className="hidden"
                  />
                </label>
              </div>
            </div>

            {/* ìº”ë²„ìŠ¤ */}
            <div className="flex-1 relative overflow-hidden">
              <svg
                ref={canvasRef}
                className="w-full h-full cursor-grab active:cursor-grabbing"
                onClick={handleCanvasClick}
                onMouseDown={handleCanvasMouseDown}
                onMouseMove={handleMouseMove}
                onMouseUp={handleMouseUp}
                onMouseLeave={handleMouseUp}
                onWheel={handleWheel}
                onContextMenu={(e) => e.preventDefault()}
                style={{
                  backgroundImage: `radial-gradient(circle, #ddd 1px, transparent 1px)`,
                  backgroundSize: `${20 * zoom}px ${20 * zoom}px`,
                  backgroundPosition: `${canvasOffset.x}px ${canvasOffset.y}px`
                }}
              >
                {smartGuides.map((guide, index) => (
                  <g key={`guide-${index}`}>
                    {guide.type === 'vertical' ? (
                      <line
                        x1={guide.position * zoom + canvasOffset.x}
                        y1={guide.range[0] * zoom + canvasOffset.y}
                        x2={guide.position * zoom + canvasOffset.x}
                        y2={guide.range[1] * zoom + canvasOffset.y}
                        stroke="#ff0080"
                        strokeWidth={1}
                        strokeDasharray="3,3"
                      />
                    ) : (
                      <line
                        x1={guide.range[0] * zoom + canvasOffset.x}
                        y1={guide.position * zoom + canvasOffset.y}
                        x2={guide.range[1] * zoom + canvasOffset.x}
                        y2={guide.position * zoom + canvasOffset.y}
                        stroke="#ff0080"
                        strokeWidth={1}
                        strokeDasharray="3,3"
                      />
                    )}
                  </g>
                ))}
                
                {selectionBox && (
                  <rect
                    x={Math.min(selectionBox.startX, selectionBox.endX) * zoom + canvasOffset.x}
                    y={Math.min(selectionBox.startY, selectionBox.endY) * zoom + canvasOffset.y}
                    width={Math.abs(selectionBox.endX - selectionBox.startX) * zoom}
                    height={Math.abs(selectionBox.endY - selectionBox.startY) * zoom}
                    fill="rgba(0, 122, 255, 0.1)"
                    stroke="rgba(0, 122, 255, 0.5)"
                    strokeWidth={1}
                    strokeDasharray="5,5"
                  />
                )}

                {connections.map(renderConnection)}
                {nodes.map(renderNode)}
              </svg>
              
              <div className="absolute top-4 right-4 bg-white rounded-lg shadow-lg p-3 text-sm">
                <div>ë…¸ë“œ: {nodes.length}ê°œ</div>
                <div>ì—°ê²°: {connections.length}ê°œ</div>
                <div>ì„ íƒë¨: {selectedNodes.length}ê°œ</div>
                {connectingFrom && <div className="text-orange-600">ì—°ê²° ëª¨ë“œ</div>}
              </div>
              
              <div className="absolute bottom-4 left-4 bg-white rounded-lg shadow-lg p-3 text-xs text-gray-600 max-w-md">
                <div><strong>ğŸ¯ PWA ë§ˆì¸ë“œë§µ v53</strong></div>
                <div className="grid grid-cols-2 gap-1 mt-1">
                  <div>V: ì„ íƒ</div>
                  <div>R: ì‚¬ê°í˜•</div>
                  <div>O: ì›í˜•</div>
                  <div>L: ì—°ê²°ì„ </div>
                </div>
                <div className="mt-2"><strong>âŒ¨ï¸ í¸ì§‘:</strong></div>
                <div>Ctrl+Z: ì‹¤í–‰ì·¨ì†Œ, Ctrl+Y: ë‹¤ì‹œì‹¤í–‰</div>
                <div>íœ í´ë¦­+ë“œë˜ê·¸: ë¶€ë“œëŸ¬ìš´ íŒ¨ë‹</div>
                <div className="mt-2"><strong>ğŸ” ë·°:</strong></div>
                <div>Ctrl+ë§ˆìš°ìŠ¤íœ : ë¶€ë“œëŸ¬ìš´ ì¤Œ, íœ : íŒ¨ë‹</div>
                <div className="mt-2"><strong>ğŸ“± PWA ê¸°ëŠ¥:</strong></div>
                <div>â€¢ ì˜¤í”„ë¼ì¸ ì‚¬ìš© ê°€ëŠ¥</div>
                <div>â€¢ ëª¨ë“  ê¸°ê¸°ì—ì„œ ì•±ìœ¼ë¡œ ì„¤ì¹˜</div>
                <div>â€¢ ê³ ê¸‰ íŒŒì¼ ì €ì¥ (ì§€ì› ë¸Œë¼ìš°ì €)</div>
              </div>
            </div>
          </div>
        );
      };

      // React ì•± ì‹œì‘
      const root = createRoot(document.getElementById('root'));
      root.render(<MiroMindMap />);
    }
  </script>
</body>
</html>
