<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#007acc">
  <meta name="description" content="개인용 마인드맵 PWA - 모든 기기에서 네이티브 앱처럼 사용">
  <title>내 마인드맵 PWA v53</title>
  
  <!-- PWA 매니페스트 -->
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="icon-192.png">
  <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="icon-512.png">
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- React 18 -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  
  <!-- Babel Standalone -->
  <script src="https://unpkg.com/@babel/standalone@7/babel.min.js"></script>
  
  <!-- Lucide Icons -->
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
  
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
      background: #f3f4f6;
    }
    #root {
      width: 100vw;
      height: 100vh;
    }
    
    /* PWA 스타일 */
    .pwa-install-prompt {
      animation: slideDown 0.3s ease-out;
    }
    
    @keyframes slideDown {
      from { transform: translateY(-100%); }
      to { transform: translateY(0); }
    }
    
    /* 로딩 애니메이션 */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      font-size: 18px;
      color: #666;
    }
    
    .spinner {
      border: 3px solid #f3f4f6;
      border-top: 3px solid #007acc;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin-right: 10px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <!-- 로딩 화면 -->
  <div id="loading" class="loading">
    <div class="spinner"></div>
    마인드맵 PWA 로딩 중...
  </div>
  
  <!-- React 앱이 렌더링될 곳 -->
  <div id="root"></div>

  <script type="text/babel">
    // 로딩 상태 관리
    const hideLoading = () => {
      const loadingEl = document.getElementById('loading');
      if (loadingEl) {
        loadingEl.style.display = 'none';
      }
    };

    // React 및 아이콘 라이브러리 확인
    if (!window.React || !window.ReactDOM || !window.lucide) {
      document.getElementById('loading').innerHTML = 
        '<div style="color: red;">필수 라이브러리 로딩 실패. 인터넷 연결을 확인해주세요.</div>';
    } else {
      // 성공적으로 로드되면 앱 시작
      startApp();
    }

    function startApp() {
      const { useState, useRef, useCallback, useEffect } = React;
      const { createRoot } = ReactDOM;

      // Lucide 아이콘들
      const {
        Square, Circle, Diamond, MousePointer, Trash2, Copy, 
        RotateCcw, RotateCw, ZoomIn, ZoomOut, Move, Download, Upload
      } = lucide;

      const MiroMindMap = () => {
        const canvasRef = useRef(null);
        const [nodes, setNodes] = useState([]);
        const [connections, setConnections] = useState([]);
        const [selectedTool, setSelectedTool] = useState('select');
        const [selectedNodes, setSelectedNodes] = useState([]);
        const [isDragging, setIsDragging] = useState(false);
        const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
        const [canvasOffset, setCanvasOffset] = useState({ x: 0, y: 0 });
        const [zoom, setZoom] = useState(1);
        const [connectingFrom, setConnectingFrom] = useState(null);
        const [editingNode, setEditingNode] = useState(null);
        const [clipboard, setClipboard] = useState([]);
        const [history, setHistory] = useState([]);
        const [historyIndex, setHistoryIndex] = useState(-1);
        const [selectionBox, setSelectionBox] = useState(null);
        const [isSelecting, setIsSelecting] = useState(false);
        const [smartGuides, setSmartGuides] = useState([]);
        const [contextMenu, setContextMenu] = useState(null);
        const [isMiddleMouseDown, setIsMiddleMouseDown] = useState(false);
        const [isInstallPromptVisible, setIsInstallPromptVisible] = useState(false);
        const [deferredPrompt, setDeferredPrompt] = useState(null);

        // 앱 로딩 완료 알림
        useEffect(() => {
          hideLoading();
        }, []);

        // PWA 설치 처리
        useEffect(() => {
          const handleBeforeInstallPrompt = (e) => {
            e.preventDefault();
            setDeferredPrompt(e);
            setIsInstallPromptVisible(true);
          };

          const handleAppInstalled = () => {
            setIsInstallPromptVisible(false);
            setDeferredPrompt(null);
            console.log('PWA가 성공적으로 설치되었습니다!');
          };

          window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
          window.addEventListener('appinstalled', handleAppInstalled);

          return () => {
            window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
            window.removeEventListener('appinstalled', handleAppInstalled);
          };
        }, []);

        const handleInstallClick = async () => {
          if (deferredPrompt) {
            deferredPrompt.prompt();
            const { outcome } = await deferredPrompt.userChoice;
            setDeferredPrompt(null);
            setIsInstallPromptVisible(false);
          }
        };

        // 노드 타입 정의
        const nodeTypes = {
          rectangle: { width: 120, height: 80, shape: 'rectangle' },
          circle: { width: 100, height: 100, shape: 'circle' },
          diamond: { width: 120, height: 80, shape: 'diamond' },
          sticky: { width: 140, height: 100, shape: 'sticky' }
        };

        // 히스토리 저장
        const saveToHistory = useCallback(() => {
          const state = { nodes, connections };
          const newHistory = history.slice(0, historyIndex + 1);
          newHistory.push(JSON.parse(JSON.stringify(state)));
          setHistory(newHistory);
          setHistoryIndex(newHistory.length - 1);
        }, [nodes, connections, history, historyIndex]);

        const undo = () => {
          if (historyIndex > 0) {
            const prevState = history[historyIndex - 1];
            setNodes(prevState.nodes);
            setConnections(prevState.connections);
            setHistoryIndex(historyIndex - 1);
          }
        };

        const redo = () => {
          if (historyIndex < history.length - 1) {
            const nextState = history[historyIndex + 1];
            setNodes(nextState.nodes);
            setConnections(nextState.connections);
            setHistoryIndex(historyIndex + 1);
          }
        };

        // 스마트 가이드 계산
        const calculateSmartGuides = useCallback((movingNodes) => {
          if (movingNodes.length === 0) return [];
          
          const guides = [];
          const snapThreshold = 8;
          const staticNodes = nodes.filter(node => !movingNodes.some(mn => mn.id === node.id));
          
          movingNodes.forEach(movingNode => {
            staticNodes.forEach(staticNode => {
              const movingCenterX = movingNode.x + movingNode.width / 2;
              const staticCenterX = staticNode.x + staticNode.width / 2;
              
              const centerDiff = Math.abs(movingCenterX - staticCenterX);
              if (centerDiff < snapThreshold) {
                const snapOffset = staticCenterX - movingCenterX;
                movingNode.x += snapOffset;
                
                guides.push({
                  type: 'vertical',
                  position: staticCenterX,
                  range: [
                    Math.min(movingNode.y, staticNode.y) - 20,
                    Math.max(movingNode.y + movingNode.height, staticNode.y + staticNode.height) + 20
                  ]
                });
              }
              
              const movingCenterY = movingNode.y + movingNode.height / 2;
              const staticCenterY = staticNode.y + staticNode.height / 2;
              
              const centerYDiff = Math.abs(movingCenterY - staticCenterY);
              if (centerYDiff < snapThreshold) {
                const snapOffset = staticCenterY - movingCenterY;
                movingNode.y += snapOffset;
                
                guides.push({
                  type: 'horizontal',
                  position: staticCenterY,
                  range: [
                    Math.min(movingNode.x, staticNode.x) - 20,
                    Math.max(movingNode.x + movingNode.width, staticNode.x + staticNode.width) + 20
                  ]
                });
              }
            });
          });
          
          return guides;
        }, [nodes]);

        // 연결점에서 새 노드 생성
        const createConnectedNode = (sourceNodeId, direction) => {
          const sourceNode = nodes.find(n => n.id === sourceNodeId);
          if (!sourceNode) return;

          let newX = sourceNode.x;
          let newY = sourceNode.y;
          const spacing = 150;

          switch (direction) {
            case 'top':
              newY = sourceNode.y - spacing;
              break;
            case 'right':
              newX = sourceNode.x + spacing;
              break;
            case 'bottom':
              newY = sourceNode.y + spacing;
              break;
            case 'left':
              newX = sourceNode.x - spacing;
              break;
          }

          const newNode = {
            id: Date.now() + Math.random(),
            x: newX,
            y: newY,
            width: sourceNode.width,
            height: sourceNode.height,
            text: 'New Node',
            color: sourceNode.color,
            borderColor: sourceNode.borderColor,
            textColor: sourceNode.textColor,
            shape: sourceNode.shape,
            fontSize: sourceNode.fontSize,
            zIndex: nodes.length
          };

          const newConnection = {
            id: Date.now() + Math.random() + 1,
            from: sourceNodeId,
            to: newNode.id,
            color: '#666666',
            width: 2,
            style: 'solid',
            hasArrow: true
          };

          setNodes(prev => [...prev, newNode]);
          setConnections(prev => [...prev, newConnection]);
          setSelectedNodes([newNode.id]);
          saveToHistory();
        };

        // 노드 생성
        const createNode = (x, y, type = 'rectangle') => {
          const nodeConfig = nodeTypes[type];
          const newNode = {
            id: Date.now() + Math.random(),
            x: (x - canvasOffset.x) / zoom,
            y: (y - canvasOffset.y) / zoom,
            width: nodeConfig.width,
            height: nodeConfig.height,
            text: 'New Node',
            color: '#ffffff',
            borderColor: '#333333',
            textColor: '#000000',
            shape: nodeConfig.shape,
            fontSize: 14,
            zIndex: nodes.length
          };
          
          setNodes(prev => [...prev, newNode]);
          saveToHistory();
        };

        // 캔버스 클릭 처리
        const handleCanvasClick = (e) => {
          setSelectedNodes([]);
          setConnectingFrom(null);
          setContextMenu(null);
          
          if (selectedTool === 'select') return;
          
          const rect = canvasRef.current.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          
          if (selectedTool !== 'select' && selectedTool !== 'connect') {
            createNode(x, y, selectedTool);
            setSelectedTool('select');
          }
        };

        // 나머지 핸들러 함수들 (간소화)
        const selectNode = (nodeId, e) => {
          e.stopPropagation();
          
          if (selectedTool === 'connect') {
            if (!connectingFrom) {
              setConnectingFrom(nodeId);
            } else {
              if (connectingFrom !== nodeId) {
                const newConnection = {
                  id: Date.now() + Math.random(),
                  from: connectingFrom,
                  to: nodeId,
                  color: '#666666',
                  width: 2,
                  style: 'solid',
                  hasArrow: true
                };
                setConnections(prev => [...prev, newConnection]);
                saveToHistory();
              }
              setConnectingFrom(null);
            }
            return;
          }

          if (e.ctrlKey || e.metaKey) {
            setSelectedNodes(prev => 
              prev.includes(nodeId) 
                ? prev.filter(id => id !== nodeId)
                : [...prev, nodeId]
            );
          } else {
            setSelectedNodes([nodeId]);
            
            const node = nodes.find(n => n.id === nodeId);
            if (node) {
              setContextMenu({
                nodeId,
                x: (node.x + node.width / 2) * zoom + canvasOffset.x,
                y: (node.y - 60) * zoom + canvasOffset.y
              });
            }
          }
        };

        // 파일 저장/로드
        const saveProject = () => {
          const project = {
            nodes,
            connections,
            canvasOffset,
            zoom,
            timestamp: new Date().toISOString(),
            version: '1.0',
            appVersion: '
